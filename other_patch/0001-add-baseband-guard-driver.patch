--- a/drivers/baseband_guard/Kconfig
+++ b/drivers/baseband_guard/Kconfig
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+
+config BASEBAND_GUARD
+    bool "Baseband Partition Guard"
+    default y
+    depends on SECURITY && BUILTIN
+    help
+      Provides write protection for critical partitions using the LSM framework.
+      This is intended to be compiled as a built-in part of the kernel.
+
--- a/drivers/baseband_guard/Makefile
+++ b/drivers/baseband_guard/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the Baseband Guard driver
+#
+obj-$(CONFIG_BASEBAND_GUARD) += baseband_guard.o
--- a/drivers/baseband_guard/baseband_guard.c
+++ b/drivers/baseband_guard/baseband_guard.c
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/security.h>
+#include <linux/lsm_hooks.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/blkdev.h>
+
+#define GUARD_ENABLED           1
+#define ALLOW_IN_RECOVERY       1
+#define PROTECT_BOOT_PARTITIONS 1
+
+static const char * const protected_partitions[] = {
+    "system", "system_ext", "vendor", "product", "odm", "data",
+    "modem", "modemst1", "modemst2", "fsg", "fsc",
+    "abl", "xbl", "xbl_config", "hyp", "tz",
+    "devinfo", "sec", "persist", "keystore", "frp",
+    "ssd", "uefisecapp", "logfs", "toolsfv",
+    "opporeserve", "oplusreserve", "multiimgoem",
+    "reserve", "cdt", "ddr", "spunvm", "splash",
+    "vbmeta", "vbmeta_system", "vbmeta_vendor",
+    NULL
+};
+
+static const char * const boot_partitions[] = {
+    "boot", "vendor_boot", "dtbo", "init_boot",
+    NULL
+};
+
+extern char *saved_command_line;
+
+static bool is_recovery_mode(void)
+{
+    if (saved_command_line && 
+        (strstr(saved_command_line, "androidboot.mode=recovery") || strstr(saved_command_line, "recovery=true"))) {
+        return true;
+    }
+    return false;
+}
+
+static int check_partition_permission(struct block_device *bdev)
+{
+    const char * const *p;
+    char bdev_name[BDEVNAME_SIZE];
+
+    if (!bdev || !bdev->bd_disk)
+        return 0;
+    
+    strlcpy(bdev_name, bdev->bd_disk->disk_name, BDEVNAME_SIZE);
+
+    for (p = protected_partitions; *p; ++p) {
+        if (strcmp(bdev_name, *p) == 0) {
+            pr_err("baseband_guard: DENIED write access to critical partition 	'%s'	\n", bdev_name);
+            return -EPERM;
+        }
+    }
+
+    if (PROTECT_BOOT_PARTITIONS) {
+        for (p = boot_partitions; *p; ++p) {
+            if (strcmp(bdev_name, *p) == 0) {
+                pr_err("baseband_guard: DENIED write access to boot partition 	'%s'	\n", bdev_name);
+                return -EPERM;
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int guard_inode_permission(struct inode *inode, int mask)
+{
+    if (!GUARD_ENABLED || !(mask & MAY_WRITE))
+        return 0;
+
+    if (ALLOW_IN_RECOVERY && is_recovery_mode()) {
+        pr_info("baseband_guard: Write allowed in recovery mode. Protection is temporarily bypassed.\n");
+        return 0;
+    }
+
+    if (S_ISBLK(inode->i_mode)) {
+        struct block_device *bdev = I_BDEV(inode);
+        int ret = 0;
+        if (bdev) {
+            ret = check_partition_permission(bdev);
+        }
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct security_hook_list baseband_guard_hooks[] __lsm_ro_after_init = {
+    LSM_HOOK_INIT(inode_permission, guard_inode_permission),
+};
+
+static int __init baseband_guard_init(void)
+{
+    pr_info("baseband_guard: Registering as a built-in LSM.\n");
+    security_add_hooks(baseband_guard_hooks, ARRAY_SIZE(baseband_guard_hooks), "baseband_guard");
+    return 0;
+}
+
+security_initcall(baseband_guard_init);
