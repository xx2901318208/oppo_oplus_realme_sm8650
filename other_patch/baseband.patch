From: CoolApk R1263599071 <2901318208@qq.com>
Date: Fri, 12 Sep 2025 14:00:00 +0000
Subject: [PATCH] security: Add dynamic and user-friendly baseband_guard LSM

This patch introduces the 'baseband_guard' Linux Security Module (LSM)
with a fully dynamic configuration interface via sysfs. It is specifically
tailored for Android kernels, providing a user-friendly experience on devices
like Realme GT5 Pro (SM8650, Android 14, GKI 6.1).

Key Features:
- **User-Friendly Naming**: Protection is based on partition names found
  in `/dev/block/by-name/` (e.g., "modem_a", "boot_a"). Users can input these
  friendly names directly into the sysfs interface.
- **Dynamic Configuration**: Exposes sysfs nodes at `/sys/kernel/baseband_guard/`:
  - `protected_list`: Read/write a comma-separated list of partitions.
  - `allow_in_recovery`: Toggle protection in recovery mode.
- **Correct Architecture & Initialization**: The module is correctly placed
  in the `security/` subsystem and uses the standard `security_initcall`
  for registration. Kconfig dependencies have been fixed.
- **Thread-Safe & Robust**: Uses mutexes for safe concurrent access and
  properly manages memory.

This version fixes critical bugs related to partition name detection (using
file_open hook for basename matching), Kconfig dependencies, and LSM
initialization, ensuring compatibility with Android GKI kernels (Linux 6.1).

Note: Protection checks the basename of the opened file path (e.g., "modem_a"
for /dev/block/by-name/modem_a). For best results, access partitions via
/dev/block/by-name/. Direct access to raw devices (e.g., /dev/mmcblk0pX)
may not trigger protection unless names match. Suitable for A/B partition
schemes on Realme GT5 Pro.

Signed-off-by: Your Name <your.email@example.com>
---
 security/Kconfig                     |   1 +
 security/Makefile                    |   1 +
 security/baseband_guard/Kconfig      |  10 +++
 security/baseband_guard/Makefile     |   2 +
 security/baseband_guard/baseband_guard.c | 215 ++++++++++++++++++++++++++++++++
 5 files changed, 229 insertions(+)
 create mode 100644 security/baseband_guard/Kconfig
 create mode 100644 security/baseband_guard/Makefile
 create mode 100644 security/baseband_guard/baseband_guard.c

diff --git a/security/Kconfig b/security/Kconfig
index 2b1b8a1..3c2d3e4 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -250,3 +250,4 @@ source "security/loadpin/Kconfig"
 source "security/safesetid/Kconfig"
 source "security/lockdown/Kconfig"
 source "security/integrity/Kconfig"
+source "security/baseband_guard/Kconfig"

diff --git a/security/Makefile b/security/Makefile
index 1a2b3c4..5d6e7f8 100644
--- a/security/Makefile
+++ b/security/Makefile
@@ -1,4 +1,5 @@
 obj-$(CONFIG_SECURITY)			+= security.o
 obj-$(CONFIG_SECURITYFS)		+= securityfs/
 obj-$(CONFIG_SECURITY_SELINUX)		+= selinux/
+obj-$(CONFIG_BASEBAND_GUARD)		+= baseband_guard/
 obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/

diff --git a/security/baseband_guard/Kconfig b/security/baseband_guard/Kconfig
new file mode 100644
index 0000000..a1b2c3d
--- /dev/null
+++ b/security/baseband_guard/Kconfig
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+
+config BASEBAND_GUARD
+	bool "Baseband Partition Guard (LSM with sysfs)"
+	default y
+	depends on SECURITY
+	help
+	  Provides write protection for critical partitions using the LSM
+	  framework, with a dynamic configuration interface via sysfs at
+	  /sys/kernel/baseband_guard/.

diff --git a/security/baseband_guard/Makefile b/security/baseband_guard/Makefile
new file mode 100644
index 0000000..e1f2g3h
--- /dev/null
+++ b/security/baseband_guard/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_BASEBAND_GUARD) += baseband_guard.o

diff --git a/security/baseband_guard/baseband_guard.c b/security/baseband_guard/baseband_guard.c
new file mode 100644
index 0000000..ab12cd3
--- /dev/null
+++ b/security/baseband_guard/baseband_guard.c
@@ -0,0 +1,215 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/security.h>
+#include <linux/lsm_hooks.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/blkdev.h>
+#include <linux/slab.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/mutex.h>
+#include <linux/namei.h>
+
+#define MAX_PROTECTED_PARTITIONS 64
+#define MAX_PARTITION_NAME_LEN 32
+
+static char *protected_partitions[MAX_PROTECTED_PARTITIONS];
+static int num_protected_partitions;
+static DEFINE_MUTEX(partition_list_lock);
+
+static bool recovery_bypass = true;
+extern char *saved_command_line;
+
+static bool is_recovery_mode(void)
+{
+	if (!recovery_bypass)
+		return false;
+
+	if (saved_command_line &&
+		(strstr(saved_command_line, "androidboot.mode=recovery") || strstr(saved_command_line, "recovery=true"))) {
+		return true;
+	}
+	return false;
+}
+
+static int guard_file_open(struct file *file)
+{
+	const char *name;
+	int i;
+
+	if (!(file->f_mode & FMODE_WRITE))
+		return 0;
+
+	struct inode *inode = file_inode(file);
+	if (!S_ISBLK(inode->i_mode))
+		return 0;
+
+	if (is_recovery_mode())
+		return 0;
+
+	/*
+	 * Use the basename of the opened file path for user-friendly matching
+	 * (e.g., "modem_a" for /dev/block/by-name/modem_a). This works well on
+	 * Android as partitions are commonly accessed via symbolic links in
+	 * /dev/block/by-name/. Note: Direct access to raw devices (e.g.,
+	 * /dev/mmcblk0pX) won't match unless the name is added explicitly.
+	 */
+	name = file_dentry(file)->d_name.name;
+
+	mutex_lock(&partition_list_lock);
+	for (i = 0; i < num_protected_partitions; i++) {
+		if (strcmp(name, protected_partitions[i]) == 0) {
+			mutex_unlock(&partition_list_lock);
+			pr_err("baseband_guard: DENIED write to protected partition '%s'\n", name);
+			return -EPERM;
+		}
+	}
+	mutex_unlock(&partition_list_lock);
+
+	return 0;
+}
+
+static void cleanup_partition_list(void)
+{
+	int i;
+	for (i = 0; i < num_protected_partitions; i++) {
+		kfree(protected_partitions[i]);
+		protected_partitions[i] = NULL;
+	}
+	num_protected_partitions = 0;
+}
+
+static ssize_t protected_list_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	int i;
+	size_t len = 0;
+
+	mutex_lock(&partition_list_lock);
+	for (i = 0; i < num_protected_partitions; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%s,", protected_partitions[i]);
+	mutex_unlock(&partition_list_lock);
+
+	if (len > 0)
+		buf[len - 1] = '\n';
+	else
+		len = scnprintf(buf, PAGE_SIZE, "\n");
+
+	return len;
+}
+
+static ssize_t protected_list_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	char *new_partitions[MAX_PROTECTED_PARTITIONS] = {0};
+	int num_new = 0;
+	char *buffer, *p, *substr;
+	int i;
+
+	buffer = kstrndup(buf, count, GFP_KERNEL);
+	if (!buffer) return -ENOMEM;
+
+	p = buffer;
+	while ((substr = strsep(&p, ",\n\r\t ")) != NULL) {
+		if (*substr == '\0') continue;
+		if (num_new >= MAX_PROTECTED_PARTITIONS) {
+			pr_warn("baseband_guard: Too many partitions, truncating list.\n");
+			break;
+		}
+		new_partitions[num_new] = kstrndup(substr, MAX_PARTITION_NAME_LEN, GFP_KERNEL);
+		if (!new_partitions[num_new]) {
+			for (i = 0; i < num_new; i++) kfree(new_partitions[i]);
+			kfree(buffer);
+			return -ENOMEM;
+		}
+		num_new++;
+	}
+
+	mutex_lock(&partition_list_lock);
+	cleanup_partition_list();
+	for (i = 0; i < num_new; i++)
+		protected_partitions[i] = new_partitions[i];
+	num_protected_partitions = num_new;
+	mutex_unlock(&partition_list_lock);
+
+	kfree(buffer);
+	pr_info("baseband_guard: Updated protected list, now protecting %d partitions.\n", num_new);
+
+	return count;
+}
+
+static ssize_t allow_in_recovery_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%d\n", recovery_bypass);
+}
+
+static ssize_t allow_in_recovery_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	bool new_val;
+	if (kstrtobool(buf, &new_val))
+		return -EINVAL;
+	recovery_bypass = new_val;
+	pr_info("baseband_guard: Recovery mode bypass set to %d\n", recovery_bypass);
+	return count;
+}
+
+static struct kobj_attribute protected_list_attr = __ATTR(protected_list, 0664, protected_list_show, protected_list_store);
+static struct kobj_attribute recovery_bypass_attr = __ATTR(allow_in_recovery, 0664, allow_in_recovery_show, allow_in_recovery_store);
+
+static struct attribute *attrs[] = {
+	&protected_list_attr.attr,
+	&recovery_bypass_attr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static struct kobject *baseband_guard_kobj;
+
+static struct security_hook_list baseband_guard_hooks[] __lsm_ro_after_init = {
+	LSM_HOOK_INIT(file_open, guard_file_open),
+};
+
+static int __init baseband_guard_init(void)
+{
+	int retval;
+
+	pr_info("baseband_guard: Registering as a built-in LSM with dynamic sysfs config.\n");
+	security_add_hooks(baseband_guard_hooks, ARRAY_SIZE(baseband_guard_hooks), "baseband_guard");
+
+	baseband_guard_kobj = kobject_create_and_add("baseband_guard", kernel_kobj);
+	if (!baseband_guard_kobj) {
+		pr_err("baseband_guard: Failed to create kobject\n");
+		return -ENOMEM;
+	}
+
+	retval = sysfs_create_group(baseband_guard_kobj, &attr_group);
+	if (retval) {
+		kobject_put(baseband_guard_kobj);
+		pr_err("baseband_guard: Failed to create sysfs group\n");
+	}
+
+	return retval;
+}
+
+security_initcall(baseband_guard_init);
